\section{Описание программного обеспечения}

\subsection{Физическое описание системы}

Файловая иерархия проекта содержит следующие компоненты:

\begin{itemize}

  \begin{item}

   \textbf{server.js} \\
    Содержит прототипы для создания демона и модели. Включает в себя
    два объекта-прототипа: \textit{Model} и \textit{Daemon} и методы:

    \begin{itemize}
        \begin{item}
          \textbf{exec(cmd)} \\
          выполняет переданную команду
        \end{item}
        \begin{item}
          \textbf{getCommands()} \\
          возвращает список доступных команд
        \end{item}
        \begin{item}
          \textbf{\_processMessage(request)} \\
          обработка команды, отправка результата клиенту
        \end{item}
        \begin{item}
          \textbf{create(model)} \\
          инициализация демона и обработчика сообщений
        \end{item}
    \end{itemize}

  \end{item}

  \begin{item}

    \textbf{index.js} \\
    Файл запуска сервера проигрывателя. Здесь происходит создание
    сервера проигрывателя на основе прототипа, расширенного
    дополнительными функциями, моделью доступа к API и списком с
    объектами доступных команд.
    
    \begin{itemize}
        \begin{item}
          \textbf{spawnMplayer(filename) } \\ запуск процесса mplayer
        \end{item}
        \begin{item}
          \textbf{ createTimePositionWatcher() } 
          \\ создание опрашивателя текущей временной позици
        \end{item}
        \begin{item}
          \textbf{ requestTimePos() } 
          \\ запрос текущей временной позиции. 
        \end{item}
        \begin{item}
          \textbf{getComments(trackId) } \\ Получение списка комментариев
        \end{item}
        \begin{item}
          \textbf{ daemon.next()} 
          \\ передать следующую композицию для воспроизведения в mplayer
        \end{item}
        \begin{item}
          \textbf{ daemon.play()} \\ начать воспроизведение
        \end{item}
    \end{itemize}

  \end{item}
  \begin{item}

    \textbf{tui.js} \\
    Файл запуска текстового клиента. 
    
    \begin{itemize}
        \begin{item}
          \textbf{timestampToObject(timestamp) } \\ перевод временной
          метки в формат объекта времени
        \end{item}
        \begin{item}
          \textbf{ formatComment(comment) } \\ форматирование
          комментария перед выводом в интерфейс
        \end{item}
        \begin{item}
          \textbf{ showPage(page) } \\ показать страницу
        \end{item}
        \begin{item}
          \textbf{ fillTrackPage(track) } \\ заполнить страницу
          описания композиции
        \end{item}
    \end{itemize}

  \end{item}

\end{itemize}

Для реализации проекта выбран язык программирования \textit{JavaScript} на
платформе \textit{Node.js}

\subsection{Язык программирования JavaScript}

\textit{JavaScript} \cite{wiki:js} --- прототипно-ориентированный сценарный язык
программирования. Является диалектом языка \textit{ECMAScript} \cite{wiki:ecma}.

JavaScript обычно используется как встраиваемый язык для программного
доступа к объектам приложений. Наиболее широкое применение находит в
браузерах как язык сценариев для реализации интерактивных веб-страниц,
но на этом ареал его распространения не ограничивается. \textit{JavaScript} все
чаще и чаще применяется в качестве языка системного программирования
настольных и серверных приложений, чему в наибольшей степени
способствует развитие платформы\textit{ Node.js}.

\subsection{Платформа Node.js}

\textit{Node.js} \cite{wiki:nodejs} --- программная платформа, основанная на
движке \textit{V8} \cite{wiki:v8}
(транслирующем \textit{JavaScript} в машинный код) и превращающая \textit{ JavaScript} из
узкоспециализированного языка в язык общего назначения. Node.js
добавляет возможность \textit{JavaScript} взаимодействовать с устройствами
ввода/вывода через свой API (написанном на C++), подключать другие
внешние библиотеки, написанные на разных языках, обеспечивая вызовы к
ним из \textit{JavaScript} кода.
\textit{Node.js} применяется преимущественно для
реализации веб-серверов, но есть возможность разрабатывать на данной платформе и
десктопные оконные приложения и даже программировать
микроконтроллеры. В основе \textit{Node.js} лежит
событийно-ориентированное и асинхронное (или реактивное)
программирование с неблокирующим вводом/выводом.

Сервер проигрывателя реализован на платформе \textit{Node.js}. Такой выбор был
сделан по нескольким причинам.

Во-первых, это существенно упрощает обработку данных, полученных с API
soundcloud, исключая из процесса обработки сериализацию,
т.к. данные приходят в родном для \textit{JavaScript} формате \textit{JSON}. Также формат \textit{JSON}
хорош тем, что существенно снижает нагрузку на сеть, по сравнению с
более объёмным XML.

Во-вторых, Node.js зарекомендовал себя как отличное средство для
реализации серверного ПО.

За счет асинхронной обработки запросов время ожидания сервера на
\textit{Node.js} сводится к минимуму, а за счет широких возможностей потоковой
обработки данных существенно снижаются затраты времени и памяти, так
как исключается избыточное копирование данных. Парадигмы асинхронных
событий и потоковой обработки данных лежат в основе платформы \textit{Node.js}.

В большинстве реализаций \textit{JavaScript} не существует возможностей для
параллельных вычислений --- все операции выполняются в одном
потоке. Для реализации асинхронных процедур и неблокирующих вычислений
используется модель EventLoop. Node.js в данном случае не является
исключением.

\subsection{Принцип работы EventLoop}

Все операции, по мере появления помещаются в очередь сообщений. Когда
подходит очередь операции, она достается, выполняется, и виток цикла
повторяется заново, со следующей командой. Поэтому все операции должны
быть атомарными и неблокирующими. Если написать цикл с большим
количеством итераций, то они поместятся в очередь \textit{EventLoop}
подряд. Если так сделать на веб-странице, то ни один элемент не будет
доступен --- когда пользователь попытается нажать на кнопку,
функция-обработчик поместиться в очередь \textit{EventLoop}, занятую в данный
момент выполнением команд итераций цикла. Чтобы избежать подобной
ситуации необходимо каждую итерацию заносить в очередь \textit{EventLoop} с
помощью обратных асинхронных вызовов. В этом и заключается смысл понятия
<<неблокирующий>>.

\subsection{ Обратные вызовы и паттерн Promise}

В следствии вышеописанного положения вещей, многие функции принимают в
качестве параметра так называемый обратный вызов, или \textit{callback }--
специальная функция, которая выполняется по заверению
операции. Так работают все асинхронные функции -- либо принимают
обратные вызовы, либо позволяют подписываться на события, о готовности данных
или о чем угодно. При таком подходе образуется т.н. <<callback hell>>,
когда уровень вложенности и кросс-вызовов становится слишком сложным
для понимания.

Для решения проблемы используется паттерн \textit{Promises}. Функции,
реализованные по этой схеме не принимают обратный вызов, а возвращают
специальный объект, в котором помимо прочего содержится функция,
выполняющая нужные операции. К нему при помощи метода \textit{.then()}
можно пристыковать еще функции, в порядке требуемой очередности
выполнения. При вызове метода \textit{.done()} все функции, переданные
ранее, поместятся в очередь EventLoop асинхронно, давая возможность
другим операция занять место между ними. Программисту же важно, что
код стал понятным, то есть ясно прослеживается и контролируется
последовательность операций внутри программы.

Такой подход позволяет реализовать асинхронную обработку запросов к
серверу в одном потоке, что дает возможность избежать тяготы отладки
многопоточных приложений.

\subsection{ Очередь сообщений ZMQ }

Сетевое взаимодействие реализовано с помощью библиотеки ZeroMQ \cite{wiki:zmq}. Она
достаточно легковесна, имеет реализации связок для большинства
популярных языков и
платформ. MQ в названии расшифровывается как \textit{message queue},
то есть библиотека реализует модель очереди сообщений.
Даже если связь с сервером прервалась,
сообщения не пропадут и будут доставлены как только это станет
возможно. Также выбор данной библиотеки обоснован простотой
использования и наличием большого сообщества пользователей.

\subsection{ Физическая архитектура }

Музыкальные файлы проигрывается с помощью CLI-утилиты
\textit{mplayer}, используемой в качестве медиа-бэкэнда. При запуске
сервер создает процесс \textit{mplayer} в режиме \textit{slave} и
захватывает его потоки \textit{stdin} и \textit{stdout}. Так сервер
управляет воспроизведением и перехватывает события времени и выхода.

Клиент реализован в текстовом интерфейсе и предназначен для запуска в
эмуляторах терминала VT100 и подобных. При наличии соответствующей возможности на
терминале выводятся цвета и символы UTF.

При запуске в командной строке можно указать адрес сервера. Для
реализации элементов интерфейса использовалась библиотека \textit{blessed}
позволяющая легко добавлять базовые элементы интерфейса (такие как
список, текстовое поле и строка) и следить за изменением размера окна
терминала.

Интерфейс может работать в режиме совместимости со стандартным
терминалом, т.е. в монохромном режиме, в размере 80х25 для полной
совместимости с терминальными мультиплексорами, такими как screen и tmux.


\subsection{Технические требования}

Программа предназначена для запуска в операционной системе \textit{Linux}. Для
запуска программ в системе должна быть установлена платформа  
\textit{Node.js}  и проигрыватель \textit{mplayer}. Для
воспроизведение необходимо подключение к интернету, приемлемое для
воспроизведения музыкальных файлов. 
